<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>pymodpde API documentation</title>
<meta name="description" content="pymodpde.py: a symbolic module that generates the modified equation for time-dependent partial differential equation
based on the used finite â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pymodpde</code></h1>
</header>
<section id="section-intro">
<p>pymodpde.py: a symbolic module that generates the modified equation for time-dependent partial differential equation
based on the used finite difference scheme.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;pymodpde.py: a symbolic module that generates the modified equation for time-dependent partial differential equation
based on the used finite difference scheme.&#34;&#34;&#34;

__author__ = &#34;Mokbel Karam , James C. Sutherland, and Tony Saad&#34;
__copyright__ = &#34;Copyright (c) 2019, Mokbel Karam&#34;

__credits__ = [&#34;University of Utah Department of Chemical Engineering&#34;]
__license__ = &#34;MIT&#34;
__version__ = &#34;1.0.0&#34;
__maintainer__ = &#34;Mokbel Karam&#34;
__email__ = &#34;mokbel.karam@chemeng.utah.edu&#34;
__status__ = &#34;Production&#34;

from sympy import *
from itertools import product
import functools


try:
    from IPython import get_ipython
    if &#39;IPKernelApp&#39; not in get_ipython().config:  # pragma: no cover
        raise ImportError(&#34;console&#34;)
    from IPython.display import display, Math, clear_output
except:
    pass

i, j, k, n = symbols(&#39;i j k n&#39;)


class DifferentialEquation:
    def __init__(self, dependentVarName: str, independentVarsNames: list, indices: list = [i, j, k],
                 timeIndex: symbol.Symbol = n):
        &#39;&#39;&#39;
        Parameters:
            dependentVarName (string): name of the dependent variable
            independentVarsNames (list of string): names of the independent variables
            indices (list of symbols): symbols for the indices of the independent variables
            timeIndex (symbol): symbolic variable of the time index

        Examples:
            &gt;&gt;&gt; DE = DifferentialEquation(dependentVarName=&#39;u&#39;, independentVarsNames=[&#39;x&#39;, &#39;y&#39;], indices=[i, j], timeIndex=n)
        &#39;&#39;&#39;

        assert isinstance(dependentVarName,
                          str), &#39;DifferentialEquation() parameter dependentVarName={} not of &lt;class &#34;str&#34;&gt;&#39;.format(
            dependentVarName)
        assert isinstance(independentVarsNames,
                          list), &#39;independentVarsNames() parameter independentVarsNames={} not of &lt;class &#34;list&#34;&gt;&#39;.format(
            independentVarsNames)
        assert isinstance(indices, list), &#39;indices() parameter indices={} not of &lt;class &#34;list&#34;&gt;&#39;.format(indices)
        assert isinstance(timeIndex,
                          symbol.Symbol), &#39;timeIndex() parameter timeIndex={} not of &lt;class &#34;sympy.core.symbol.Symbol&#34;&gt;&#39;.format(
            timeIndex)
        for indepVar in independentVarsNames:
            assert isinstance(indepVar, str), &#39;independentVarsNames members are not of &lt;class &#34;str&#34;&gt;&#39;.format(independentVarsNames)
        for index in indices:
            assert isinstance(index,
                              symbol.Symbol), &#39;indices members are not of &lt;class &#34;sympy.core.symbol.Symbol&#34;&gt;&#39;.format(
                indices)

        if len(independentVarsNames) &gt; 3:
            raise Exception(&#39;No more than three independent variable is allowed!&#39;)
        else:
            self.__independentVars = independentVarsNames
            self.__dependentVar_name = dependentVarName

            self.__indices = indices
            self.__timeIndex = timeIndex

            self.__independent_vars()

            setattr(self, self.__dependentVar_name, self.dependent_var_func)
            self.indepVarsSym = [self.vars[var][&#39;sym&#39;] for var in self.__independentVars]
            self.indepVarsSym.append(self.t[&#39;sym&#39;])
            self.dependentVar = Function(self.__dependentVar_name)(*self.indepVarsSym)

            self.__latex_ME_coefs = {&#39;lhs&#39;: &#39;&#39;, &#39;rhs&#39;: {}}

            self.indicies = {}
            for var in self.__independentVars:
                self.indicies[var] = self.vars[var][&#39;index&#39;]
            self.lhs = (self.dependent_var_func(self.t[&#39;index&#39;] + 1, **self.indicies) - self.dependent_var_func(
                self.t[&#39;index&#39;],
                **self.indicies)) / \
                       self.t[&#39;variation&#39;]
            self.rhs = None

            self.__latex_amp_factor = None
            self.__ME = None
            self.__amp_factor = None
            self.__amp_factor_exponent = None
            self.__latex_amp_factor_exponent = None
            self.__latex_ME = None

            self.__is_jupyter = None
            try:
                self.__is_jupyter = &#39;IPKernelApp&#39; in get_ipython().config
            except:
                self.__is_jupyter = False

    def symbolic_modified_equation(self):
        &#39;&#39;&#39;
        Returns:
             the symbolic modified equation
        &#39;&#39;&#39;
        if self.__ME == None:
            raise Exception(
                &#39;the modified equation is not generated yet. try calling the generate_modified_equation function first.&#39;)
        else:
            return self.__ME


    def latex_modified_equation(self):
        &#39;&#39;&#39;
        Returns:
             the Latex string of the modified equation
        &#39;&#39;&#39;
        if self.__ME == None:
            raise Exception(
                &#39;the modified equation is not generated yet. try calling the generate_modified_equation function first.&#39;)
        else:
            return self.__latex()


    def latex_amp_factor(self):
        &#39;&#39;&#39;
        Returns:
             the Latex string of the amplification factor
        &#39;&#39;&#39;
        if self.__amp_factor == None:
            raise Exception(&#39;the amplification factor is not generated yet. try calling the generate_modified_equation or generate_amp_factor functions first.&#39;)
        return self.__latex_amp_factor


    def symbolic_amp_factor(self):
        &#39;&#39;&#39;
        Returns:
             the symbolic amplification factor
        &#39;&#39;&#39;
        if self.__amp_factor == None:
            raise Exception(&#39;the amplification factor is not generated yet. try calling the generate_modified_equation or generate_amp_factor functions first.&#39;)
        else:
            return self.__amp_factor

    def __printer(foo):
        &#39;&#39;&#39;
        decorator that prints the results based on where they are executed: jupyter or script
        &#39;&#39;&#39;
        @functools.wraps(foo)
        def Print(self, *args, **kwargs):
            if self.__is_jupyter:
                return display(Math(foo(self, *args, **kwargs)))
            else:
                symbolic_form = foo(self, *args, **kwargs)
                subs_dict = {}
                for indep in self.indepVarsSym:
                    subs_dict[&#39;\Delta{}&#39;.format(&#39;{&#39;+str(indep)+&#39;}&#39;)] = var(&#39;d{}&#39;.format(str(indep)))
                return pprint(symbolic_form.subs(subs_dict))
        return Print

    @__printer
    def display_modified_equation(self):
        &#39;&#39;&#39;
        Display the modified equation in a latex rendered form in jupyter cell and render the symbolic equation in console or
        python script.
        &#39;&#39;&#39;
        if self.__ME == None:
            raise Exception(&#39;the amplification factor is not generated yet. Try calling the generate_modified_equation or generate_amp_factor functions first.&#39;)
        if self.__is_jupyter:
            return self.__latex_ME
        else:
            return self.__ME

    @__printer
    def display_amp_factor(self):
        &#39;&#39;&#39;
           Display the amplification factor in a latex rendered form in jupyter cell and render the symbolic equation in console or
           python script.
       &#39;&#39;&#39;
        if self.__amp_factor == None:
            raise Exception(&#39;the modified equation is not generated yet. Try calling the generate_modified_equation function first.&#39;)
        if self.__is_jupyter:
            return latex(self.__amp_factor)
        else:
            return self.__amp_factor


    def independentVars(self):
        &#39;&#39;&#39;
        Returns:
            self.__independentVars (list): list of independent variables names
        &#39;&#39;&#39;
        return self.__independentVars

    def __independent_vars(self):
        &#39;&#39;&#39;
        Defines the symbols for the independent variables, differential elements, wave number variables, and indices
        &#39;&#39;&#39;
        self.vars = {}
        self.t = {}
        num = 1
        for var, index in zip(self.__independentVars, self.__indices):
            self.vars[var] = {}
            varName = &#39;indepVar{}&#39;.format(num)
            setattr(self, varName, symbols(var))
            self.vars[var][&#39;sym&#39;] = getattr(self, varName)
            waveNumName = &#39;k{}&#39;.format(num)
            setattr(self, waveNumName, symbols(waveNumName))
            self.vars[var][&#39;waveNum&#39;] = getattr(self, waveNumName)
            variationName = &#39;d{}&#39;.format(var)
            variationSymStr = &#39;\Delta{}&#39;.format(&#39;{&#39;+var+&#39;}&#39;)
            setattr(self, variationName, symbols(variationSymStr))
            self.vars[var][&#39;variation&#39;] = getattr(self, variationName)
            self.vars[var][&#39;index&#39;] = index
            num += 1
        self.t[&#39;sym&#39;] = symbols(&#39;t&#39;)
        self.t[&#39;ampFactor&#39;] = symbols(&#39;q&#39;)
        setattr(self, &#39;dt&#39;, symbols(&#39;\Delta{t}&#39;))
        self.t[&#39;variation&#39;] = getattr(self, &#39;dt&#39;)
        self.t[&#39;index&#39;] = self.__timeIndex

    def dependent_var_func(self, time, **kwargs):
        &#39;&#39;&#39;
        The function assigned to the dependent variable name. It has the following form exp(alpha tn) exp(ikx) exp(iky) ...

        Parameters:
            time (symbolic expression): time step at which we are applying this function ex: n, n+1, n-1, ..., &lt;timeIndex\&gt; + number.
            kwargs (symbolic expression): the stencil points at which we are applying this function ex: x=i+3, y=j+1, ..., &lt;independentVar\&gt; = &lt;spatialIndex\&gt; + number

        Returns:
            symbolic expression of this function applied at time index and points

        Examples:

            &gt;&gt;&gt; &lt;DE&gt;.&lt;dependentVar&gt;(time=n+1, x=i+1, y=j)

            the following example is about advection using Forward in Time and Upwind in Space (FTUS) scheme

            &gt;&gt;&gt; i, j, n, a = symbols(&#34;i j n a&#34;)
            &gt;&gt;&gt; DE = DifferentialEquation(dependentVarName=&#39;u&#39;, independentVarsNames=[&#39;x&#39;, &#39;y&#39;], indices=[i, j], timeIndex=n)
            &gt;&gt;&gt; advection = -a (DE.u(time=n, x=i, y=j) - DE.u(time=n, x=i-1, y=j))/DE.dx
            &gt;&gt;&gt; DE.set_rhs(advection)
            &gt;&gt;&gt; pretty_print(DE.generate_modified_equation(nterms=2))

            another example where we change the name of the dependent variable from &#39;u&#39; to &#39;f&#39;
            &gt;&gt;&gt; i, j, n, a = symbols(&#34;i j n a&#34;)
            &gt;&gt;&gt; DE = DifferentialEquation(dependentVarName=&#39;f&#39;, independentVarsNames=[&#39;x&#39;, &#39;y&#39;], indices=[i, j], timeIndex=n)
            &gt;&gt;&gt; advection = -a (DE.f(time=n, x=i, y=j) - DE.f(time=n, x=i-1, y=j))/DE.dx
            &gt;&gt;&gt; DE.set_rhs(advection)
            &gt;&gt;&gt; pretty_print(DE.generate_modified_equation(nterms=2))
        &#39;&#39;&#39;

        assert isinstance(time, add.Add) or isinstance(time,
                                                       symbol.Symbol), &#39;dependent_var_func() parameter time={} not of &lt;class &#34;sympy.core.add.Add&#34;&gt;, or &lt;class &#34;sympy.core.symbol.Symbol&#34;&gt;&#39;.format(
            time)
        time_symbols = list(time.free_symbols)
        for sym in time_symbols:
            assert sym == self.t[
                &#39;index&#39;], &#39;dependent_var_func() parameter time={} inappropriate time index is used. Use {} instead.&#39;.format(
                time, self.t[&#39;index&#39;])

        keys = list(kwargs.keys())

        for var in keys:
            var_symbols = list(kwargs[var].free_symbols)
            assert len(
                var_symbols) == 1, &#39;dependent_var_func() parameter {}={} inappropriate number of indecies is used for {}&#39;.format(
                var, kwargs[var], var)
            assert var_symbols[0] == self.vars[var][
                &#39;index&#39;], &#39;dependent_var_func() parameter {}={} other index is used for {}. Use {} index instead.&#39;.format(
                var, kwargs[var], var, self.vars[var][&#39;index&#39;])

        expression = exp(self.t[&#39;ampFactor&#39;] * (self.t[&#39;sym&#39;] + (time - self.t[&#39;index&#39;]) * self.t[&#39;variation&#39;]))
        for var in keys:
            expression *= exp(1j * self.vars[var][&#39;waveNum&#39;] * (
                    self.vars[var][&#39;sym&#39;] + (kwargs[var] - self.vars[var][&#39;index&#39;]) * self.vars[var][&#39;variation&#39;]))
        return expression

    def __stencil_gen(self, points: list, order: int):
        &#39;&#39;&#39;
        Generates finite difference equation based on the location of sampled points and derivative order

        Parameters:
            points (list int): stencil of length N needed ex: [-1,0,1] stencil around 0
            order (int &gt; 0): the order of derivatives d, d&lt;N

        Returns:
             the finite difference coefficients along with the points used in a dictionary
                {&#39;points&#39;:[],&#39;coefs&#39;:[]}

        Examples:
            &gt;&gt;&gt; &lt;DE&gt;.__stencil_gen(points=[-1,0],order=1)
        &#39;&#39;&#39;

        assert isinstance(points, list), &#39;__stencil_gen() parameter points={} not of &lt;class &#34;list&#34;&gt;&#39;.format(points)
        for pt in points:
            assert isinstance(pt, int), &#39;elements of points={} are not of &lt;class &#34;int&#34;&gt;&#39;.format(points)
        assert order &lt; len(points), &#39;Enter a derivative order that is less than the number of points in your stencil.&#39;

        numPts = len(points)
        M = []
        for i in range(numPts):
            M.append([s ** i for s in points])
        M = Matrix(M)
        b = Matrix([factorial(order) * 1 if j == order else 0 for j in range(numPts)])
        coefs = list(M.inv() * b)
        return {&#39;points&#39;: points, &#39;coefs&#39;: coefs}

    def expr(self, order, directionName, time, stencil):
        &#39;&#39;&#39;
        Generates an expression based on the stencil, the directionName,  order of the derivative, and the time at which the expression is evaluated.

        Parameters:
            order (int): order of the derivative
            directionName (string): the name of the independent variable that indicate the directionName of the derivative
            time (symbolic expression): time at which to evaluate the expression. ex: n+1 or n
            stencil (list of int): N points used for the stencil gen function

        Returns:
            symbolic expression

        Examples:
             &gt;&gt;&gt; &lt;DE&gt;.expr(order=1, directionName=&#39;x&#39;, time=n, stencil=[-1,0])
        &#39;&#39;&#39;

        assert isinstance(directionName, str), &#39;exp() parameter direcction={} not of &lt;class &#34;str&#34;&gt;&#39;.format(directionName)
        assert directionName in self.__independentVars, &#39;direcction={} not an independent variable. indepVar={}&#39;.format(
            directionName, self.__independentVars)
        assert isinstance(time, add.Add) \
               or isinstance(time,symbol.Symbol), \
               &#39;expr() parameter time={} not of &lt;class &#34;sympy.core.add.Add&#34;&gt;,&#39; \
               &#39; or &lt;class &#34;sympy.core.symbol.Symbol&#34;&gt;&#39;.format(time)

        time_symbols = list(time.free_symbols)
        for sym in time_symbols:
            assert sym == self.t[
                &#39;index&#39;], &#39;dependent_var_func() parameter time={} inappropriate time index is used. Use {} instead.&#39;.format(
                time, self.t[&#39;index&#39;])

        stencil = self.__stencil_gen(stencil, order)
        expression = 0
        for coef, pt in zip(stencil[&#39;coefs&#39;], stencil[&#39;points&#39;]):

            kwargs = {}
            for var in self.__independentVars:
                if var == directionName:
                    kwargs[var] = self.vars[directionName][&#39;index&#39;] + pt
                else:
                    kwargs[var] = self.vars[var][&#39;index&#39;]
            expression += coef * self.dependent_var_func(time=time, **kwargs) / (
                    self.vars[directionName][&#39;variation&#39;] ** order)
        return ratsimp(expression)


    def generate_modified_equation(self, nterms):
        &#39;&#39;&#39;
        Computes the values of the modified equation coefficients a_{ijk} where i, j and k represent
        the order of derivatives in the &lt;indep var1\&gt; , &lt;indep var2\&gt;, and &lt;indep var3\&gt; directions, respectively. These are written as
        a_ijk * u_{ijk}.

        Parameters:
            nterms (int): Number of in the modified equation. nterms is greater than zero.

        Examples:
            &gt;&gt;&gt; &lt;DE&gt;.generate_modified_equation(nterms=2)
        &#39;&#39;&#39;
        assert nterms &gt; 0, &#39;generate_modified_equation() member nterms={} has to be greater than zero.&#39;.format(nterms)
        self.generate_amp_factor()
        q = self.__solve_amp_exponent()

        order = self.__infer_order(q) # infering maximum order from the amplification factor.

        couples = (i for i in product(list(range(0, order + nterms)), repeat=len(self.__independentVars)) if
                   (sum(i) &lt; order + nterms and sum(i) &gt; 0))

        coefs = {}
        derivs = {}
        for couple in couples:
            wrt_vars = []
            wrt_wave_num = []
            waveNum = {}
            fac = 1
            N = 0
            ies = &#39;&#39;

            for num, var in enumerate(self.__independentVars):
                wrt_wave_num.append(self.vars[var][&#39;waveNum&#39;])
                waveNum[self.vars[var][&#39;waveNum&#39;]] = 0
                wrt_wave_num.append(couple[num])
                wrt_vars.append(self.vars[var][&#39;sym&#39;])
                wrt_vars.append(couple[num])
                N = sum(couple)
                fac *= factorial(couple[num])
                ies += str(couple[num])

            diff_ = diff(q, *wrt_wave_num).subs(waveNum)
            frac = ratsimp(1 / (fac * I ** N))
            coefficient = simplify(frac * diff_)
            if coefficient != 0:
                coefs[&#39;a{}&#39;.format(ies)] = nsimplify(coefficient)
                derivs[&#39;a{}&#39;.format(ies)] = Derivative(self.dependentVar, *wrt_vars)

        me_lhs = Derivative(self.dependentVar, self.t[&#39;sym&#39;], 1)
        me_rhs = 0
        self.__latex_ME_coefs[&#39;lhs&#39;] = latex(me_lhs)
        for key in coefs.keys():
            me_rhs += coefs[key] * derivs[key]
            self.__latex_ME_coefs[&#39;rhs&#39;][key[1:]] = latex(coefs[key]) + &#39; &#39; + latex(derivs[key])
        self.__ME = Eq(me_lhs, me_rhs)
        self.__latex_ME = self.__latex()

    def __infer_order(self, amp_factor):
        &#39;&#39;&#39;
        This function is used to infer the highest derivative order on  the rhs of the PDE using the amplification factor.
        this is done by counting the instances of differential elements and by searching for combinations of these elements
        in the amplification factor.
        :param amp_factor: symbolic expression of the amplification factor
        :return: (int) the order-derivative of the PDE&#39;s RHS.
        &#39;&#39;&#39;

        maximums = [0 for _ in range(
            len(self.__independentVars))]  # initiating a list with zeros based on the number of independent variables
        orders = []  # list that store the order each derivative with respect to one independent variable ( not for cross derivative)

        def rep(expr):
            &#39;&#39;&#39;
            Recursive function that traverse the symbolic tree searching for the differential elements (represents derivative order)
            and store the results in a list.
            :param expr: a symbolic expression
            :return: None
            &#39;&#39;&#39;
            base_expr = expr.as_base_exp()  # infer the exponents of the expression
            # if (len(base_expr) == 2 ) and (str(self.dx) == str(base_expr[0]) or str(self.dy) == str(base_expr[0])):
            if (len(base_expr) == 2) and any(list(
                    [str(self.vars[self.__independentVars[num]][&#39;variation&#39;]) == str(base_expr[0]) for num in
                     range(len(self.__independentVars))])):
                # if the base expr is one of the differential elements store that into the orders list
                orders.append(base_expr)
                # print(expr.as_base_exp())
            for arg in expr.args:
                rep(arg)  # recursively call rep to transverse the amplification factor symbolic tree.

        rep(amp_factor)  # calling the function rep

        # in this for loop we go over all the values in orders and look for the maximum value of exponents
        # and store them in an organized way in maximums list
        for arg in orders:
            for num, var in enumerate(self.__independentVars):
                if arg[0] == self.vars[var][&#39;variation&#39;]:
                    maximums[num] = max(maximums[num], abs(arg[1]))

                # print(generate_amp_factor.has(self.vars[var][&#39;variation&#39;]**maximums[num]))

        # checking for cross derivatives orders.
        ranges = [range(-max, max + 1) for max in maximums]
        # print(*ranges)
        products = list(product(*ranges))
        # print(list(products))

        comb_max = 0
        for p in products:
            var_comb = 1
            for num in range(len(maximums)):
                var_comb *= self.vars[self.__independentVars[num]][&#39;variation&#39;] ** p[num]

            if amp_factor.has(var_comb):
                comb_max = max(comb_max, sum([abs(p[i]) for i in range(len(p))]))

            # print(&#39;{}, {}&#39;.format(var_comb,generate_amp_factor.has(var_comb)))

        # choosing the maximum value for order between derivatives and cross derivatives.
        order = max(max(maximums), comb_max)

        # value for the maximum order on the rhs
        return order


    def __solve_amp_exponent(self):
        &#39;&#39;&#39;
        Solve for the amplification factor of the numerical discritazation of the partial differential equation

        Returns:
             (expression): symbolic expression of the rhs of the amplification factor
        &#39;&#39;&#39;
        e_alpha_dt = self.__amp_factor.rhs
        q = 1/self.t[&#39;variation&#39;] * log(e_alpha_dt)  # alpha
        self.__amp_factor_exponent = q
        return q

    def __solve_amp_factor(self):
        A = symbols(&#39;A&#39;)
        # compute the amplification factor
        lhs1 = simplify(self.lhs / self.dependent_var_func(self.t[&#39;index&#39;], **self.indicies))
        rhs1 = simplify(self.rhs / self.dependent_var_func(self.t[&#39;index&#39;], **self.indicies))
        eq = lhs1 - rhs1
        eq = eq.subs(exp(self.t[&#39;ampFactor&#39;] * self.t[&#39;variation&#39;]), A)
        eq = eq.subs(exp(self.t[&#39;variation&#39;] * self.t[&#39;ampFactor&#39;]), A)
        eq = expand(eq)
        eq = collect(eq, A)
        e_alpha_dt = simplify(solve(eq, A)[0])
        return e_alpha_dt

    def generate_amp_factor(self):
        &#39;&#39;&#39;
        Computes the amplification factor for the discretized PDE
        &#39;&#39;&#39;
        lhs = exp(symbols(&#39;alpha&#39;)*self.t[&#39;variation&#39;])
        rhs = self.__solve_amp_factor()
        self.__amp_factor = Eq(lhs,rhs)
        self.__latex_amp_factor = latex(self.__amp_factor)

    def __latex(self):
        &#39;&#39;&#39;
        Returns:
            latex (string): Latex representation of the modified equation as &#39; lhs = rhs &#39;

        &#39;&#39;&#39;
        strings = {}
        for key in self.__latex_ME_coefs[&#39;rhs&#39;].keys():
            num = sum([int(x) for x in [char for char in key]])
            string = self.__latex_ME_coefs[&#39;rhs&#39;][key]
            string = self.__latex_derivative(string)
            if num in list(strings.keys()):
                strings[num] += &#39; &#39; + string if string[0] == &#39;-&#39; else &#39; + &#39; + string
            else:
                strings[num] = &#39; &#39; + string if string[0] == &#39;-&#39; else &#39; + &#39; + string
        lhs_string = self.__latex_ME_coefs[&#39;lhs&#39;]
        lhs_string= self.__latex_derivative(lhs_string)

        latex_str = lhs_string + &#39; = &#39;
        for i in sorted(strings.keys()):
            latex_str += strings[i]
        return latex_str

    def __latex_derivative(self,string):
        firstDelPos = string.rfind(&#34;{&#34;)
        secondDelPos = string.rfind(&#34;}&#34;)
        string = string.replace(string[firstDelPos:secondDelPos + 1], &#34;&#34;)
        var_string = &#34; &#34; + string[-1] + &#34; &#34;
        string = string[:-1]
        rPartialPos = string.rfind(&#34;partial&#34;)
        varNewPos = string[:rPartialPos].rfind(&#34;}{&#34;)
        string = string[:varNewPos] + var_string + string[varNewPos:]
        return string

    def __set_lhs(self):
        &#39;&#39;&#39;
        This function is not defined yet.
        &#39;&#39;&#39;
        raise Exception(&#39;For now we only support by default first order time derivative.&#39;)

    def set_rhs(self, expression):
        &#39;&#39;&#39;
        sets the rhs of the DifferentialEquation
        Parameters:
            expression (symbolic expression): linear combination of expression generated from &lt;DE\&gt;.expr(...) or &lt;DE\&gt;.&lt;dependentVar\&gt;(...)

        Examples:
            &gt;&gt;&gt; DE = DifferentialEquation(dependentVarName=&#34;u&#34;,independentVarsNames =[&#34;x&#34;])
            &gt;&gt;&gt; a = symbols(&#39;a&#39;)

            using DE.expr(...)

            &gt;&gt;&gt; advectionTerm = DE.expr(order=1,directionName=&#34;x&#34;,time=n,stencil=[-1, 0])
            &gt;&gt;&gt; DE.set_rhs(expression= - a * advectionTerm)

            or using  DE.&lt;dependentVar\&gt;(...)

            &gt;&gt;&gt; advectionTerm = (DE.u(time=n, x=i) - DE.u(time=n, x=i-1))/DE.dx
            &gt;&gt;&gt; DE.set_rhs(expression= - a * advectionTerm)

        &#39;&#39;&#39;

        assert not isinstance(expression, str), &#39;set_rhs() parameter expression={} not a symbolic expression&#39;.format(
            expression)

        self.rhs = expression

    def __rhs(self):
        &#39;&#39;&#39;
        Returns:
             (expression):  the rhs of the differential equation
        &#39;&#39;&#39;
        return self.rhs

    def __lhs(self):
        &#39;&#39;&#39;
        Returns:
            (expression):  the lhs of the differential equation
        &#39;&#39;&#39;
        return self.lhs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pymodpde.DifferentialEquation"><code class="flex name class">
<span>class <span class="ident">DifferentialEquation</span></span>
<span>(</span><span>dependentVarName, independentVarsNames, indices=[i, j, k], timeIndex=n)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dependentVarName</code></strong> :&ensp;<code>string</code></dt>
<dd>name of the dependent variable</dd>
<dt><strong><code>independentVarsNames</code></strong> :&ensp;<code>list</code> of <code>string</code></dt>
<dd>names of the independent variables</dd>
<dt><strong><code>indices</code></strong> :&ensp;<code>list</code> of <code>symbols</code></dt>
<dd>symbols for the indices of the independent variables</dd>
<dt><strong><code>timeIndex</code></strong> :&ensp;<code>symbol</code></dt>
<dd>symbolic variable of the time index</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; DE = DifferentialEquation(dependentVarName='u', independentVarsNames=['x', 'y'], indices=[i, j], timeIndex=n)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DifferentialEquation:
    def __init__(self, dependentVarName: str, independentVarsNames: list, indices: list = [i, j, k],
                 timeIndex: symbol.Symbol = n):
        &#39;&#39;&#39;
        Parameters:
            dependentVarName (string): name of the dependent variable
            independentVarsNames (list of string): names of the independent variables
            indices (list of symbols): symbols for the indices of the independent variables
            timeIndex (symbol): symbolic variable of the time index

        Examples:
            &gt;&gt;&gt; DE = DifferentialEquation(dependentVarName=&#39;u&#39;, independentVarsNames=[&#39;x&#39;, &#39;y&#39;], indices=[i, j], timeIndex=n)
        &#39;&#39;&#39;

        assert isinstance(dependentVarName,
                          str), &#39;DifferentialEquation() parameter dependentVarName={} not of &lt;class &#34;str&#34;&gt;&#39;.format(
            dependentVarName)
        assert isinstance(independentVarsNames,
                          list), &#39;independentVarsNames() parameter independentVarsNames={} not of &lt;class &#34;list&#34;&gt;&#39;.format(
            independentVarsNames)
        assert isinstance(indices, list), &#39;indices() parameter indices={} not of &lt;class &#34;list&#34;&gt;&#39;.format(indices)
        assert isinstance(timeIndex,
                          symbol.Symbol), &#39;timeIndex() parameter timeIndex={} not of &lt;class &#34;sympy.core.symbol.Symbol&#34;&gt;&#39;.format(
            timeIndex)
        for indepVar in independentVarsNames:
            assert isinstance(indepVar, str), &#39;independentVarsNames members are not of &lt;class &#34;str&#34;&gt;&#39;.format(independentVarsNames)
        for index in indices:
            assert isinstance(index,
                              symbol.Symbol), &#39;indices members are not of &lt;class &#34;sympy.core.symbol.Symbol&#34;&gt;&#39;.format(
                indices)

        if len(independentVarsNames) &gt; 3:
            raise Exception(&#39;No more than three independent variable is allowed!&#39;)
        else:
            self.__independentVars = independentVarsNames
            self.__dependentVar_name = dependentVarName

            self.__indices = indices
            self.__timeIndex = timeIndex

            self.__independent_vars()

            setattr(self, self.__dependentVar_name, self.dependent_var_func)
            self.indepVarsSym = [self.vars[var][&#39;sym&#39;] for var in self.__independentVars]
            self.indepVarsSym.append(self.t[&#39;sym&#39;])
            self.dependentVar = Function(self.__dependentVar_name)(*self.indepVarsSym)

            self.__latex_ME_coefs = {&#39;lhs&#39;: &#39;&#39;, &#39;rhs&#39;: {}}

            self.indicies = {}
            for var in self.__independentVars:
                self.indicies[var] = self.vars[var][&#39;index&#39;]
            self.lhs = (self.dependent_var_func(self.t[&#39;index&#39;] + 1, **self.indicies) - self.dependent_var_func(
                self.t[&#39;index&#39;],
                **self.indicies)) / \
                       self.t[&#39;variation&#39;]
            self.rhs = None

            self.__latex_amp_factor = None
            self.__ME = None
            self.__amp_factor = None
            self.__amp_factor_exponent = None
            self.__latex_amp_factor_exponent = None
            self.__latex_ME = None

            self.__is_jupyter = None
            try:
                self.__is_jupyter = &#39;IPKernelApp&#39; in get_ipython().config
            except:
                self.__is_jupyter = False

    def symbolic_modified_equation(self):
        &#39;&#39;&#39;
        Returns:
             the symbolic modified equation
        &#39;&#39;&#39;
        if self.__ME == None:
            raise Exception(
                &#39;the modified equation is not generated yet. try calling the generate_modified_equation function first.&#39;)
        else:
            return self.__ME


    def latex_modified_equation(self):
        &#39;&#39;&#39;
        Returns:
             the Latex string of the modified equation
        &#39;&#39;&#39;
        if self.__ME == None:
            raise Exception(
                &#39;the modified equation is not generated yet. try calling the generate_modified_equation function first.&#39;)
        else:
            return self.__latex()


    def latex_amp_factor(self):
        &#39;&#39;&#39;
        Returns:
             the Latex string of the amplification factor
        &#39;&#39;&#39;
        if self.__amp_factor == None:
            raise Exception(&#39;the amplification factor is not generated yet. try calling the generate_modified_equation or generate_amp_factor functions first.&#39;)
        return self.__latex_amp_factor


    def symbolic_amp_factor(self):
        &#39;&#39;&#39;
        Returns:
             the symbolic amplification factor
        &#39;&#39;&#39;
        if self.__amp_factor == None:
            raise Exception(&#39;the amplification factor is not generated yet. try calling the generate_modified_equation or generate_amp_factor functions first.&#39;)
        else:
            return self.__amp_factor

    def __printer(foo):
        &#39;&#39;&#39;
        decorator that prints the results based on where they are executed: jupyter or script
        &#39;&#39;&#39;
        @functools.wraps(foo)
        def Print(self, *args, **kwargs):
            if self.__is_jupyter:
                return display(Math(foo(self, *args, **kwargs)))
            else:
                symbolic_form = foo(self, *args, **kwargs)
                subs_dict = {}
                for indep in self.indepVarsSym:
                    subs_dict[&#39;\Delta{}&#39;.format(&#39;{&#39;+str(indep)+&#39;}&#39;)] = var(&#39;d{}&#39;.format(str(indep)))
                return pprint(symbolic_form.subs(subs_dict))
        return Print

    @__printer
    def display_modified_equation(self):
        &#39;&#39;&#39;
        Display the modified equation in a latex rendered form in jupyter cell and render the symbolic equation in console or
        python script.
        &#39;&#39;&#39;
        if self.__ME == None:
            raise Exception(&#39;the amplification factor is not generated yet. Try calling the generate_modified_equation or generate_amp_factor functions first.&#39;)
        if self.__is_jupyter:
            return self.__latex_ME
        else:
            return self.__ME

    @__printer
    def display_amp_factor(self):
        &#39;&#39;&#39;
           Display the amplification factor in a latex rendered form in jupyter cell and render the symbolic equation in console or
           python script.
       &#39;&#39;&#39;
        if self.__amp_factor == None:
            raise Exception(&#39;the modified equation is not generated yet. Try calling the generate_modified_equation function first.&#39;)
        if self.__is_jupyter:
            return latex(self.__amp_factor)
        else:
            return self.__amp_factor


    def independentVars(self):
        &#39;&#39;&#39;
        Returns:
            self.__independentVars (list): list of independent variables names
        &#39;&#39;&#39;
        return self.__independentVars

    def __independent_vars(self):
        &#39;&#39;&#39;
        Defines the symbols for the independent variables, differential elements, wave number variables, and indices
        &#39;&#39;&#39;
        self.vars = {}
        self.t = {}
        num = 1
        for var, index in zip(self.__independentVars, self.__indices):
            self.vars[var] = {}
            varName = &#39;indepVar{}&#39;.format(num)
            setattr(self, varName, symbols(var))
            self.vars[var][&#39;sym&#39;] = getattr(self, varName)
            waveNumName = &#39;k{}&#39;.format(num)
            setattr(self, waveNumName, symbols(waveNumName))
            self.vars[var][&#39;waveNum&#39;] = getattr(self, waveNumName)
            variationName = &#39;d{}&#39;.format(var)
            variationSymStr = &#39;\Delta{}&#39;.format(&#39;{&#39;+var+&#39;}&#39;)
            setattr(self, variationName, symbols(variationSymStr))
            self.vars[var][&#39;variation&#39;] = getattr(self, variationName)
            self.vars[var][&#39;index&#39;] = index
            num += 1
        self.t[&#39;sym&#39;] = symbols(&#39;t&#39;)
        self.t[&#39;ampFactor&#39;] = symbols(&#39;q&#39;)
        setattr(self, &#39;dt&#39;, symbols(&#39;\Delta{t}&#39;))
        self.t[&#39;variation&#39;] = getattr(self, &#39;dt&#39;)
        self.t[&#39;index&#39;] = self.__timeIndex

    def dependent_var_func(self, time, **kwargs):
        &#39;&#39;&#39;
        The function assigned to the dependent variable name. It has the following form exp(alpha tn) exp(ikx) exp(iky) ...

        Parameters:
            time (symbolic expression): time step at which we are applying this function ex: n, n+1, n-1, ..., &lt;timeIndex\&gt; + number.
            kwargs (symbolic expression): the stencil points at which we are applying this function ex: x=i+3, y=j+1, ..., &lt;independentVar\&gt; = &lt;spatialIndex\&gt; + number

        Returns:
            symbolic expression of this function applied at time index and points

        Examples:

            &gt;&gt;&gt; &lt;DE&gt;.&lt;dependentVar&gt;(time=n+1, x=i+1, y=j)

            the following example is about advection using Forward in Time and Upwind in Space (FTUS) scheme

            &gt;&gt;&gt; i, j, n, a = symbols(&#34;i j n a&#34;)
            &gt;&gt;&gt; DE = DifferentialEquation(dependentVarName=&#39;u&#39;, independentVarsNames=[&#39;x&#39;, &#39;y&#39;], indices=[i, j], timeIndex=n)
            &gt;&gt;&gt; advection = -a (DE.u(time=n, x=i, y=j) - DE.u(time=n, x=i-1, y=j))/DE.dx
            &gt;&gt;&gt; DE.set_rhs(advection)
            &gt;&gt;&gt; pretty_print(DE.generate_modified_equation(nterms=2))

            another example where we change the name of the dependent variable from &#39;u&#39; to &#39;f&#39;
            &gt;&gt;&gt; i, j, n, a = symbols(&#34;i j n a&#34;)
            &gt;&gt;&gt; DE = DifferentialEquation(dependentVarName=&#39;f&#39;, independentVarsNames=[&#39;x&#39;, &#39;y&#39;], indices=[i, j], timeIndex=n)
            &gt;&gt;&gt; advection = -a (DE.f(time=n, x=i, y=j) - DE.f(time=n, x=i-1, y=j))/DE.dx
            &gt;&gt;&gt; DE.set_rhs(advection)
            &gt;&gt;&gt; pretty_print(DE.generate_modified_equation(nterms=2))
        &#39;&#39;&#39;

        assert isinstance(time, add.Add) or isinstance(time,
                                                       symbol.Symbol), &#39;dependent_var_func() parameter time={} not of &lt;class &#34;sympy.core.add.Add&#34;&gt;, or &lt;class &#34;sympy.core.symbol.Symbol&#34;&gt;&#39;.format(
            time)
        time_symbols = list(time.free_symbols)
        for sym in time_symbols:
            assert sym == self.t[
                &#39;index&#39;], &#39;dependent_var_func() parameter time={} inappropriate time index is used. Use {} instead.&#39;.format(
                time, self.t[&#39;index&#39;])

        keys = list(kwargs.keys())

        for var in keys:
            var_symbols = list(kwargs[var].free_symbols)
            assert len(
                var_symbols) == 1, &#39;dependent_var_func() parameter {}={} inappropriate number of indecies is used for {}&#39;.format(
                var, kwargs[var], var)
            assert var_symbols[0] == self.vars[var][
                &#39;index&#39;], &#39;dependent_var_func() parameter {}={} other index is used for {}. Use {} index instead.&#39;.format(
                var, kwargs[var], var, self.vars[var][&#39;index&#39;])

        expression = exp(self.t[&#39;ampFactor&#39;] * (self.t[&#39;sym&#39;] + (time - self.t[&#39;index&#39;]) * self.t[&#39;variation&#39;]))
        for var in keys:
            expression *= exp(1j * self.vars[var][&#39;waveNum&#39;] * (
                    self.vars[var][&#39;sym&#39;] + (kwargs[var] - self.vars[var][&#39;index&#39;]) * self.vars[var][&#39;variation&#39;]))
        return expression

    def __stencil_gen(self, points: list, order: int):
        &#39;&#39;&#39;
        Generates finite difference equation based on the location of sampled points and derivative order

        Parameters:
            points (list int): stencil of length N needed ex: [-1,0,1] stencil around 0
            order (int &gt; 0): the order of derivatives d, d&lt;N

        Returns:
             the finite difference coefficients along with the points used in a dictionary
                {&#39;points&#39;:[],&#39;coefs&#39;:[]}

        Examples:
            &gt;&gt;&gt; &lt;DE&gt;.__stencil_gen(points=[-1,0],order=1)
        &#39;&#39;&#39;

        assert isinstance(points, list), &#39;__stencil_gen() parameter points={} not of &lt;class &#34;list&#34;&gt;&#39;.format(points)
        for pt in points:
            assert isinstance(pt, int), &#39;elements of points={} are not of &lt;class &#34;int&#34;&gt;&#39;.format(points)
        assert order &lt; len(points), &#39;Enter a derivative order that is less than the number of points in your stencil.&#39;

        numPts = len(points)
        M = []
        for i in range(numPts):
            M.append([s ** i for s in points])
        M = Matrix(M)
        b = Matrix([factorial(order) * 1 if j == order else 0 for j in range(numPts)])
        coefs = list(M.inv() * b)
        return {&#39;points&#39;: points, &#39;coefs&#39;: coefs}

    def expr(self, order, directionName, time, stencil):
        &#39;&#39;&#39;
        Generates an expression based on the stencil, the directionName,  order of the derivative, and the time at which the expression is evaluated.

        Parameters:
            order (int): order of the derivative
            directionName (string): the name of the independent variable that indicate the directionName of the derivative
            time (symbolic expression): time at which to evaluate the expression. ex: n+1 or n
            stencil (list of int): N points used for the stencil gen function

        Returns:
            symbolic expression

        Examples:
             &gt;&gt;&gt; &lt;DE&gt;.expr(order=1, directionName=&#39;x&#39;, time=n, stencil=[-1,0])
        &#39;&#39;&#39;

        assert isinstance(directionName, str), &#39;exp() parameter direcction={} not of &lt;class &#34;str&#34;&gt;&#39;.format(directionName)
        assert directionName in self.__independentVars, &#39;direcction={} not an independent variable. indepVar={}&#39;.format(
            directionName, self.__independentVars)
        assert isinstance(time, add.Add) \
               or isinstance(time,symbol.Symbol), \
               &#39;expr() parameter time={} not of &lt;class &#34;sympy.core.add.Add&#34;&gt;,&#39; \
               &#39; or &lt;class &#34;sympy.core.symbol.Symbol&#34;&gt;&#39;.format(time)

        time_symbols = list(time.free_symbols)
        for sym in time_symbols:
            assert sym == self.t[
                &#39;index&#39;], &#39;dependent_var_func() parameter time={} inappropriate time index is used. Use {} instead.&#39;.format(
                time, self.t[&#39;index&#39;])

        stencil = self.__stencil_gen(stencil, order)
        expression = 0
        for coef, pt in zip(stencil[&#39;coefs&#39;], stencil[&#39;points&#39;]):

            kwargs = {}
            for var in self.__independentVars:
                if var == directionName:
                    kwargs[var] = self.vars[directionName][&#39;index&#39;] + pt
                else:
                    kwargs[var] = self.vars[var][&#39;index&#39;]
            expression += coef * self.dependent_var_func(time=time, **kwargs) / (
                    self.vars[directionName][&#39;variation&#39;] ** order)
        return ratsimp(expression)


    def generate_modified_equation(self, nterms):
        &#39;&#39;&#39;
        Computes the values of the modified equation coefficients a_{ijk} where i, j and k represent
        the order of derivatives in the &lt;indep var1\&gt; , &lt;indep var2\&gt;, and &lt;indep var3\&gt; directions, respectively. These are written as
        a_ijk * u_{ijk}.

        Parameters:
            nterms (int): Number of in the modified equation. nterms is greater than zero.

        Examples:
            &gt;&gt;&gt; &lt;DE&gt;.generate_modified_equation(nterms=2)
        &#39;&#39;&#39;
        assert nterms &gt; 0, &#39;generate_modified_equation() member nterms={} has to be greater than zero.&#39;.format(nterms)
        self.generate_amp_factor()
        q = self.__solve_amp_exponent()

        order = self.__infer_order(q) # infering maximum order from the amplification factor.

        couples = (i for i in product(list(range(0, order + nterms)), repeat=len(self.__independentVars)) if
                   (sum(i) &lt; order + nterms and sum(i) &gt; 0))

        coefs = {}
        derivs = {}
        for couple in couples:
            wrt_vars = []
            wrt_wave_num = []
            waveNum = {}
            fac = 1
            N = 0
            ies = &#39;&#39;

            for num, var in enumerate(self.__independentVars):
                wrt_wave_num.append(self.vars[var][&#39;waveNum&#39;])
                waveNum[self.vars[var][&#39;waveNum&#39;]] = 0
                wrt_wave_num.append(couple[num])
                wrt_vars.append(self.vars[var][&#39;sym&#39;])
                wrt_vars.append(couple[num])
                N = sum(couple)
                fac *= factorial(couple[num])
                ies += str(couple[num])

            diff_ = diff(q, *wrt_wave_num).subs(waveNum)
            frac = ratsimp(1 / (fac * I ** N))
            coefficient = simplify(frac * diff_)
            if coefficient != 0:
                coefs[&#39;a{}&#39;.format(ies)] = nsimplify(coefficient)
                derivs[&#39;a{}&#39;.format(ies)] = Derivative(self.dependentVar, *wrt_vars)

        me_lhs = Derivative(self.dependentVar, self.t[&#39;sym&#39;], 1)
        me_rhs = 0
        self.__latex_ME_coefs[&#39;lhs&#39;] = latex(me_lhs)
        for key in coefs.keys():
            me_rhs += coefs[key] * derivs[key]
            self.__latex_ME_coefs[&#39;rhs&#39;][key[1:]] = latex(coefs[key]) + &#39; &#39; + latex(derivs[key])
        self.__ME = Eq(me_lhs, me_rhs)
        self.__latex_ME = self.__latex()

    def __infer_order(self, amp_factor):
        &#39;&#39;&#39;
        This function is used to infer the highest derivative order on  the rhs of the PDE using the amplification factor.
        this is done by counting the instances of differential elements and by searching for combinations of these elements
        in the amplification factor.
        :param amp_factor: symbolic expression of the amplification factor
        :return: (int) the order-derivative of the PDE&#39;s RHS.
        &#39;&#39;&#39;

        maximums = [0 for _ in range(
            len(self.__independentVars))]  # initiating a list with zeros based on the number of independent variables
        orders = []  # list that store the order each derivative with respect to one independent variable ( not for cross derivative)

        def rep(expr):
            &#39;&#39;&#39;
            Recursive function that traverse the symbolic tree searching for the differential elements (represents derivative order)
            and store the results in a list.
            :param expr: a symbolic expression
            :return: None
            &#39;&#39;&#39;
            base_expr = expr.as_base_exp()  # infer the exponents of the expression
            # if (len(base_expr) == 2 ) and (str(self.dx) == str(base_expr[0]) or str(self.dy) == str(base_expr[0])):
            if (len(base_expr) == 2) and any(list(
                    [str(self.vars[self.__independentVars[num]][&#39;variation&#39;]) == str(base_expr[0]) for num in
                     range(len(self.__independentVars))])):
                # if the base expr is one of the differential elements store that into the orders list
                orders.append(base_expr)
                # print(expr.as_base_exp())
            for arg in expr.args:
                rep(arg)  # recursively call rep to transverse the amplification factor symbolic tree.

        rep(amp_factor)  # calling the function rep

        # in this for loop we go over all the values in orders and look for the maximum value of exponents
        # and store them in an organized way in maximums list
        for arg in orders:
            for num, var in enumerate(self.__independentVars):
                if arg[0] == self.vars[var][&#39;variation&#39;]:
                    maximums[num] = max(maximums[num], abs(arg[1]))

                # print(generate_amp_factor.has(self.vars[var][&#39;variation&#39;]**maximums[num]))

        # checking for cross derivatives orders.
        ranges = [range(-max, max + 1) for max in maximums]
        # print(*ranges)
        products = list(product(*ranges))
        # print(list(products))

        comb_max = 0
        for p in products:
            var_comb = 1
            for num in range(len(maximums)):
                var_comb *= self.vars[self.__independentVars[num]][&#39;variation&#39;] ** p[num]

            if amp_factor.has(var_comb):
                comb_max = max(comb_max, sum([abs(p[i]) for i in range(len(p))]))

            # print(&#39;{}, {}&#39;.format(var_comb,generate_amp_factor.has(var_comb)))

        # choosing the maximum value for order between derivatives and cross derivatives.
        order = max(max(maximums), comb_max)

        # value for the maximum order on the rhs
        return order


    def __solve_amp_exponent(self):
        &#39;&#39;&#39;
        Solve for the amplification factor of the numerical discritazation of the partial differential equation

        Returns:
             (expression): symbolic expression of the rhs of the amplification factor
        &#39;&#39;&#39;
        e_alpha_dt = self.__amp_factor.rhs
        q = 1/self.t[&#39;variation&#39;] * log(e_alpha_dt)  # alpha
        self.__amp_factor_exponent = q
        return q

    def __solve_amp_factor(self):
        A = symbols(&#39;A&#39;)
        # compute the amplification factor
        lhs1 = simplify(self.lhs / self.dependent_var_func(self.t[&#39;index&#39;], **self.indicies))
        rhs1 = simplify(self.rhs / self.dependent_var_func(self.t[&#39;index&#39;], **self.indicies))
        eq = lhs1 - rhs1
        eq = eq.subs(exp(self.t[&#39;ampFactor&#39;] * self.t[&#39;variation&#39;]), A)
        eq = eq.subs(exp(self.t[&#39;variation&#39;] * self.t[&#39;ampFactor&#39;]), A)
        eq = expand(eq)
        eq = collect(eq, A)
        e_alpha_dt = simplify(solve(eq, A)[0])
        return e_alpha_dt

    def generate_amp_factor(self):
        &#39;&#39;&#39;
        Computes the amplification factor for the discretized PDE
        &#39;&#39;&#39;
        lhs = exp(symbols(&#39;alpha&#39;)*self.t[&#39;variation&#39;])
        rhs = self.__solve_amp_factor()
        self.__amp_factor = Eq(lhs,rhs)
        self.__latex_amp_factor = latex(self.__amp_factor)

    def __latex(self):
        &#39;&#39;&#39;
        Returns:
            latex (string): Latex representation of the modified equation as &#39; lhs = rhs &#39;

        &#39;&#39;&#39;
        strings = {}
        for key in self.__latex_ME_coefs[&#39;rhs&#39;].keys():
            num = sum([int(x) for x in [char for char in key]])
            string = self.__latex_ME_coefs[&#39;rhs&#39;][key]
            string = self.__latex_derivative(string)
            if num in list(strings.keys()):
                strings[num] += &#39; &#39; + string if string[0] == &#39;-&#39; else &#39; + &#39; + string
            else:
                strings[num] = &#39; &#39; + string if string[0] == &#39;-&#39; else &#39; + &#39; + string
        lhs_string = self.__latex_ME_coefs[&#39;lhs&#39;]
        lhs_string= self.__latex_derivative(lhs_string)

        latex_str = lhs_string + &#39; = &#39;
        for i in sorted(strings.keys()):
            latex_str += strings[i]
        return latex_str

    def __latex_derivative(self,string):
        firstDelPos = string.rfind(&#34;{&#34;)
        secondDelPos = string.rfind(&#34;}&#34;)
        string = string.replace(string[firstDelPos:secondDelPos + 1], &#34;&#34;)
        var_string = &#34; &#34; + string[-1] + &#34; &#34;
        string = string[:-1]
        rPartialPos = string.rfind(&#34;partial&#34;)
        varNewPos = string[:rPartialPos].rfind(&#34;}{&#34;)
        string = string[:varNewPos] + var_string + string[varNewPos:]
        return string

    def __set_lhs(self):
        &#39;&#39;&#39;
        This function is not defined yet.
        &#39;&#39;&#39;
        raise Exception(&#39;For now we only support by default first order time derivative.&#39;)

    def set_rhs(self, expression):
        &#39;&#39;&#39;
        sets the rhs of the DifferentialEquation
        Parameters:
            expression (symbolic expression): linear combination of expression generated from &lt;DE\&gt;.expr(...) or &lt;DE\&gt;.&lt;dependentVar\&gt;(...)

        Examples:
            &gt;&gt;&gt; DE = DifferentialEquation(dependentVarName=&#34;u&#34;,independentVarsNames =[&#34;x&#34;])
            &gt;&gt;&gt; a = symbols(&#39;a&#39;)

            using DE.expr(...)

            &gt;&gt;&gt; advectionTerm = DE.expr(order=1,directionName=&#34;x&#34;,time=n,stencil=[-1, 0])
            &gt;&gt;&gt; DE.set_rhs(expression= - a * advectionTerm)

            or using  DE.&lt;dependentVar\&gt;(...)

            &gt;&gt;&gt; advectionTerm = (DE.u(time=n, x=i) - DE.u(time=n, x=i-1))/DE.dx
            &gt;&gt;&gt; DE.set_rhs(expression= - a * advectionTerm)

        &#39;&#39;&#39;

        assert not isinstance(expression, str), &#39;set_rhs() parameter expression={} not a symbolic expression&#39;.format(
            expression)

        self.rhs = expression

    def __rhs(self):
        &#39;&#39;&#39;
        Returns:
             (expression):  the rhs of the differential equation
        &#39;&#39;&#39;
        return self.rhs

    def __lhs(self):
        &#39;&#39;&#39;
        Returns:
            (expression):  the lhs of the differential equation
        &#39;&#39;&#39;
        return self.lhs</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pymodpde.DifferentialEquation.dependent_var_func"><code class="name flex">
<span>def <span class="ident">dependent_var_func</span></span>(<span>self, time, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>The function assigned to the dependent variable name. It has the following form exp(alpha tn) exp(ikx) exp(iky) &hellip;</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time</code></strong> :&ensp;<code>symbolic</code> <code>expression</code></dt>
<dd>time step at which we are applying this function ex: n, n+1, n-1, &hellip;, &lt;timeIndex> + number.</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>symbolic</code> <code>expression</code></dt>
<dd>the stencil points at which we are applying this function ex: x=i+3, y=j+1, &hellip;, &lt;independentVar> = &lt;spatialIndex> + number</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>symbolic</code> <code>expression</code> of <code>this</code> <code>function</code> <code>applied</code> <code>at</code> <code>time</code> <code>index</code> <code>and</code> <code>points</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; &lt;DE&gt;.&lt;dependentVar&gt;(time=n+1, x=i+1, y=j)
</code></pre>
<p>the following example is about advection using Forward in Time and Upwind in Space (FTUS) scheme</p>
<pre><code>&gt;&gt;&gt; i, j, n, a = symbols("i j n a")
&gt;&gt;&gt; DE = DifferentialEquation(dependentVarName='u', independentVarsNames=['x', 'y'], indices=[i, j], timeIndex=n)
&gt;&gt;&gt; advection = -a (DE.u(time=n, x=i, y=j) - DE.u(time=n, x=i-1, y=j))/DE.dx
&gt;&gt;&gt; DE.set_rhs(advection)
&gt;&gt;&gt; pretty_print(DE.generate_modified_equation(nterms=2))
</code></pre>
<p>another example where we change the name of the dependent variable from 'u' to 'f'</p>
<pre><code>&gt;&gt;&gt; i, j, n, a = symbols("i j n a")
&gt;&gt;&gt; DE = DifferentialEquation(dependentVarName='f', independentVarsNames=['x', 'y'], indices=[i, j], timeIndex=n)
&gt;&gt;&gt; advection = -a (DE.f(time=n, x=i, y=j) - DE.f(time=n, x=i-1, y=j))/DE.dx
&gt;&gt;&gt; DE.set_rhs(advection)
&gt;&gt;&gt; pretty_print(DE.generate_modified_equation(nterms=2))
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dependent_var_func(self, time, **kwargs):
    &#39;&#39;&#39;
    The function assigned to the dependent variable name. It has the following form exp(alpha tn) exp(ikx) exp(iky) ...

    Parameters:
        time (symbolic expression): time step at which we are applying this function ex: n, n+1, n-1, ..., &lt;timeIndex\&gt; + number.
        kwargs (symbolic expression): the stencil points at which we are applying this function ex: x=i+3, y=j+1, ..., &lt;independentVar\&gt; = &lt;spatialIndex\&gt; + number

    Returns:
        symbolic expression of this function applied at time index and points

    Examples:

        &gt;&gt;&gt; &lt;DE&gt;.&lt;dependentVar&gt;(time=n+1, x=i+1, y=j)

        the following example is about advection using Forward in Time and Upwind in Space (FTUS) scheme

        &gt;&gt;&gt; i, j, n, a = symbols(&#34;i j n a&#34;)
        &gt;&gt;&gt; DE = DifferentialEquation(dependentVarName=&#39;u&#39;, independentVarsNames=[&#39;x&#39;, &#39;y&#39;], indices=[i, j], timeIndex=n)
        &gt;&gt;&gt; advection = -a (DE.u(time=n, x=i, y=j) - DE.u(time=n, x=i-1, y=j))/DE.dx
        &gt;&gt;&gt; DE.set_rhs(advection)
        &gt;&gt;&gt; pretty_print(DE.generate_modified_equation(nterms=2))

        another example where we change the name of the dependent variable from &#39;u&#39; to &#39;f&#39;
        &gt;&gt;&gt; i, j, n, a = symbols(&#34;i j n a&#34;)
        &gt;&gt;&gt; DE = DifferentialEquation(dependentVarName=&#39;f&#39;, independentVarsNames=[&#39;x&#39;, &#39;y&#39;], indices=[i, j], timeIndex=n)
        &gt;&gt;&gt; advection = -a (DE.f(time=n, x=i, y=j) - DE.f(time=n, x=i-1, y=j))/DE.dx
        &gt;&gt;&gt; DE.set_rhs(advection)
        &gt;&gt;&gt; pretty_print(DE.generate_modified_equation(nterms=2))
    &#39;&#39;&#39;

    assert isinstance(time, add.Add) or isinstance(time,
                                                   symbol.Symbol), &#39;dependent_var_func() parameter time={} not of &lt;class &#34;sympy.core.add.Add&#34;&gt;, or &lt;class &#34;sympy.core.symbol.Symbol&#34;&gt;&#39;.format(
        time)
    time_symbols = list(time.free_symbols)
    for sym in time_symbols:
        assert sym == self.t[
            &#39;index&#39;], &#39;dependent_var_func() parameter time={} inappropriate time index is used. Use {} instead.&#39;.format(
            time, self.t[&#39;index&#39;])

    keys = list(kwargs.keys())

    for var in keys:
        var_symbols = list(kwargs[var].free_symbols)
        assert len(
            var_symbols) == 1, &#39;dependent_var_func() parameter {}={} inappropriate number of indecies is used for {}&#39;.format(
            var, kwargs[var], var)
        assert var_symbols[0] == self.vars[var][
            &#39;index&#39;], &#39;dependent_var_func() parameter {}={} other index is used for {}. Use {} index instead.&#39;.format(
            var, kwargs[var], var, self.vars[var][&#39;index&#39;])

    expression = exp(self.t[&#39;ampFactor&#39;] * (self.t[&#39;sym&#39;] + (time - self.t[&#39;index&#39;]) * self.t[&#39;variation&#39;]))
    for var in keys:
        expression *= exp(1j * self.vars[var][&#39;waveNum&#39;] * (
                self.vars[var][&#39;sym&#39;] + (kwargs[var] - self.vars[var][&#39;index&#39;]) * self.vars[var][&#39;variation&#39;]))
    return expression</code></pre>
</details>
</dd>
<dt id="pymodpde.DifferentialEquation.display_amp_factor"><code class="name flex">
<span>def <span class="ident">display_amp_factor</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Display the amplification factor in a latex rendered form in jupyter cell and render the symbolic equation in console or
python script.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@__printer
def display_amp_factor(self):
    &#39;&#39;&#39;
       Display the amplification factor in a latex rendered form in jupyter cell and render the symbolic equation in console or
       python script.
   &#39;&#39;&#39;
    if self.__amp_factor == None:
        raise Exception(&#39;the modified equation is not generated yet. Try calling the generate_modified_equation function first.&#39;)
    if self.__is_jupyter:
        return latex(self.__amp_factor)
    else:
        return self.__amp_factor</code></pre>
</details>
</dd>
<dt id="pymodpde.DifferentialEquation.display_modified_equation"><code class="name flex">
<span>def <span class="ident">display_modified_equation</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Display the modified equation in a latex rendered form in jupyter cell and render the symbolic equation in console or
python script.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@__printer
def display_modified_equation(self):
    &#39;&#39;&#39;
    Display the modified equation in a latex rendered form in jupyter cell and render the symbolic equation in console or
    python script.
    &#39;&#39;&#39;
    if self.__ME == None:
        raise Exception(&#39;the amplification factor is not generated yet. Try calling the generate_modified_equation or generate_amp_factor functions first.&#39;)
    if self.__is_jupyter:
        return self.__latex_ME
    else:
        return self.__ME</code></pre>
</details>
</dd>
<dt id="pymodpde.DifferentialEquation.expr"><code class="name flex">
<span>def <span class="ident">expr</span></span>(<span>self, order, directionName, time, stencil)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates an expression based on the stencil, the directionName,
order of the derivative, and the time at which the expression is evaluated.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code></dt>
<dd>order of the derivative</dd>
<dt><strong><code>directionName</code></strong> :&ensp;<code>string</code></dt>
<dd>the name of the independent variable that indicate the directionName of the derivative</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>symbolic</code> <code>expression</code></dt>
<dd>time at which to evaluate the expression. ex: n+1 or n</dd>
<dt><strong><code>stencil</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>N points used for the stencil gen function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>symbolic</code> <code>expression</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; &lt;DE&gt;.expr(order=1, directionName='x', time=n, stencil=[-1,0])
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expr(self, order, directionName, time, stencil):
    &#39;&#39;&#39;
    Generates an expression based on the stencil, the directionName,  order of the derivative, and the time at which the expression is evaluated.

    Parameters:
        order (int): order of the derivative
        directionName (string): the name of the independent variable that indicate the directionName of the derivative
        time (symbolic expression): time at which to evaluate the expression. ex: n+1 or n
        stencil (list of int): N points used for the stencil gen function

    Returns:
        symbolic expression

    Examples:
         &gt;&gt;&gt; &lt;DE&gt;.expr(order=1, directionName=&#39;x&#39;, time=n, stencil=[-1,0])
    &#39;&#39;&#39;

    assert isinstance(directionName, str), &#39;exp() parameter direcction={} not of &lt;class &#34;str&#34;&gt;&#39;.format(directionName)
    assert directionName in self.__independentVars, &#39;direcction={} not an independent variable. indepVar={}&#39;.format(
        directionName, self.__independentVars)
    assert isinstance(time, add.Add) \
           or isinstance(time,symbol.Symbol), \
           &#39;expr() parameter time={} not of &lt;class &#34;sympy.core.add.Add&#34;&gt;,&#39; \
           &#39; or &lt;class &#34;sympy.core.symbol.Symbol&#34;&gt;&#39;.format(time)

    time_symbols = list(time.free_symbols)
    for sym in time_symbols:
        assert sym == self.t[
            &#39;index&#39;], &#39;dependent_var_func() parameter time={} inappropriate time index is used. Use {} instead.&#39;.format(
            time, self.t[&#39;index&#39;])

    stencil = self.__stencil_gen(stencil, order)
    expression = 0
    for coef, pt in zip(stencil[&#39;coefs&#39;], stencil[&#39;points&#39;]):

        kwargs = {}
        for var in self.__independentVars:
            if var == directionName:
                kwargs[var] = self.vars[directionName][&#39;index&#39;] + pt
            else:
                kwargs[var] = self.vars[var][&#39;index&#39;]
        expression += coef * self.dependent_var_func(time=time, **kwargs) / (
                self.vars[directionName][&#39;variation&#39;] ** order)
    return ratsimp(expression)</code></pre>
</details>
</dd>
<dt id="pymodpde.DifferentialEquation.generate_amp_factor"><code class="name flex">
<span>def <span class="ident">generate_amp_factor</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes the amplification factor for the discretized PDE</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_amp_factor(self):
    &#39;&#39;&#39;
    Computes the amplification factor for the discretized PDE
    &#39;&#39;&#39;
    lhs = exp(symbols(&#39;alpha&#39;)*self.t[&#39;variation&#39;])
    rhs = self.__solve_amp_factor()
    self.__amp_factor = Eq(lhs,rhs)
    self.__latex_amp_factor = latex(self.__amp_factor)</code></pre>
</details>
</dd>
<dt id="pymodpde.DifferentialEquation.generate_modified_equation"><code class="name flex">
<span>def <span class="ident">generate_modified_equation</span></span>(<span>self, nterms)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes the values of the modified equation coefficients a_{ijk} where i, j and k represent
the order of derivatives in the &lt;indep var1> , &lt;indep var2>, and &lt;indep var3> directions, respectively. These are written as
a_ijk * u_{ijk}.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nterms</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of in the modified equation. nterms is greater than zero.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; &lt;DE&gt;.generate_modified_equation(nterms=2)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_modified_equation(self, nterms):
    &#39;&#39;&#39;
    Computes the values of the modified equation coefficients a_{ijk} where i, j and k represent
    the order of derivatives in the &lt;indep var1\&gt; , &lt;indep var2\&gt;, and &lt;indep var3\&gt; directions, respectively. These are written as
    a_ijk * u_{ijk}.

    Parameters:
        nterms (int): Number of in the modified equation. nterms is greater than zero.

    Examples:
        &gt;&gt;&gt; &lt;DE&gt;.generate_modified_equation(nterms=2)
    &#39;&#39;&#39;
    assert nterms &gt; 0, &#39;generate_modified_equation() member nterms={} has to be greater than zero.&#39;.format(nterms)
    self.generate_amp_factor()
    q = self.__solve_amp_exponent()

    order = self.__infer_order(q) # infering maximum order from the amplification factor.

    couples = (i for i in product(list(range(0, order + nterms)), repeat=len(self.__independentVars)) if
               (sum(i) &lt; order + nterms and sum(i) &gt; 0))

    coefs = {}
    derivs = {}
    for couple in couples:
        wrt_vars = []
        wrt_wave_num = []
        waveNum = {}
        fac = 1
        N = 0
        ies = &#39;&#39;

        for num, var in enumerate(self.__independentVars):
            wrt_wave_num.append(self.vars[var][&#39;waveNum&#39;])
            waveNum[self.vars[var][&#39;waveNum&#39;]] = 0
            wrt_wave_num.append(couple[num])
            wrt_vars.append(self.vars[var][&#39;sym&#39;])
            wrt_vars.append(couple[num])
            N = sum(couple)
            fac *= factorial(couple[num])
            ies += str(couple[num])

        diff_ = diff(q, *wrt_wave_num).subs(waveNum)
        frac = ratsimp(1 / (fac * I ** N))
        coefficient = simplify(frac * diff_)
        if coefficient != 0:
            coefs[&#39;a{}&#39;.format(ies)] = nsimplify(coefficient)
            derivs[&#39;a{}&#39;.format(ies)] = Derivative(self.dependentVar, *wrt_vars)

    me_lhs = Derivative(self.dependentVar, self.t[&#39;sym&#39;], 1)
    me_rhs = 0
    self.__latex_ME_coefs[&#39;lhs&#39;] = latex(me_lhs)
    for key in coefs.keys():
        me_rhs += coefs[key] * derivs[key]
        self.__latex_ME_coefs[&#39;rhs&#39;][key[1:]] = latex(coefs[key]) + &#39; &#39; + latex(derivs[key])
    self.__ME = Eq(me_lhs, me_rhs)
    self.__latex_ME = self.__latex()</code></pre>
</details>
</dd>
<dt id="pymodpde.DifferentialEquation.independentVars"><code class="name flex">
<span>def <span class="ident">independentVars</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>self.__independentVars</code> (<code>list</code>): <code>list</code> of <code>independent</code> <code>variables</code> <code>names</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def independentVars(self):
    &#39;&#39;&#39;
    Returns:
        self.__independentVars (list): list of independent variables names
    &#39;&#39;&#39;
    return self.__independentVars</code></pre>
</details>
</dd>
<dt id="pymodpde.DifferentialEquation.latex_amp_factor"><code class="name flex">
<span>def <span class="ident">latex_amp_factor</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>the</code> <code>Latex</code> <code>string</code> of <code>the</code> <code>amplification</code> <code>factor</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def latex_amp_factor(self):
    &#39;&#39;&#39;
    Returns:
         the Latex string of the amplification factor
    &#39;&#39;&#39;
    if self.__amp_factor == None:
        raise Exception(&#39;the amplification factor is not generated yet. try calling the generate_modified_equation or generate_amp_factor functions first.&#39;)
    return self.__latex_amp_factor</code></pre>
</details>
</dd>
<dt id="pymodpde.DifferentialEquation.latex_modified_equation"><code class="name flex">
<span>def <span class="ident">latex_modified_equation</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>the</code> <code>Latex</code> <code>string</code> of <code>the</code> <code>modified</code> <code>equation</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def latex_modified_equation(self):
    &#39;&#39;&#39;
    Returns:
         the Latex string of the modified equation
    &#39;&#39;&#39;
    if self.__ME == None:
        raise Exception(
            &#39;the modified equation is not generated yet. try calling the generate_modified_equation function first.&#39;)
    else:
        return self.__latex()</code></pre>
</details>
</dd>
<dt id="pymodpde.DifferentialEquation.set_rhs"><code class="name flex">
<span>def <span class="ident">set_rhs</span></span>(<span>self, expression)</span>
</code></dt>
<dd>
<section class="desc"><p>sets the rhs of the DifferentialEquation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>symbolic</code> <code>expression</code></dt>
<dd>linear combination of expression generated from &lt;DE>.expr(&hellip;) or &lt;DE>.&lt;dependentVar>(&hellip;)</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; DE = DifferentialEquation(dependentVarName="u",independentVarsNames =["x"])
&gt;&gt;&gt; a = symbols('a')
</code></pre>
<p>using DE.expr(&hellip;)</p>
<pre><code>&gt;&gt;&gt; advectionTerm = DE.expr(order=1,directionName="x",time=n,stencil=[-1, 0])
&gt;&gt;&gt; DE.set_rhs(expression= - a * advectionTerm)
</code></pre>
<p>or using
DE.&lt;dependentVar>(&hellip;)</p>
<pre><code>&gt;&gt;&gt; advectionTerm = (DE.u(time=n, x=i) - DE.u(time=n, x=i-1))/DE.dx
&gt;&gt;&gt; DE.set_rhs(expression= - a * advectionTerm)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rhs(self, expression):
    &#39;&#39;&#39;
    sets the rhs of the DifferentialEquation
    Parameters:
        expression (symbolic expression): linear combination of expression generated from &lt;DE\&gt;.expr(...) or &lt;DE\&gt;.&lt;dependentVar\&gt;(...)

    Examples:
        &gt;&gt;&gt; DE = DifferentialEquation(dependentVarName=&#34;u&#34;,independentVarsNames =[&#34;x&#34;])
        &gt;&gt;&gt; a = symbols(&#39;a&#39;)

        using DE.expr(...)

        &gt;&gt;&gt; advectionTerm = DE.expr(order=1,directionName=&#34;x&#34;,time=n,stencil=[-1, 0])
        &gt;&gt;&gt; DE.set_rhs(expression= - a * advectionTerm)

        or using  DE.&lt;dependentVar\&gt;(...)

        &gt;&gt;&gt; advectionTerm = (DE.u(time=n, x=i) - DE.u(time=n, x=i-1))/DE.dx
        &gt;&gt;&gt; DE.set_rhs(expression= - a * advectionTerm)

    &#39;&#39;&#39;

    assert not isinstance(expression, str), &#39;set_rhs() parameter expression={} not a symbolic expression&#39;.format(
        expression)

    self.rhs = expression</code></pre>
</details>
</dd>
<dt id="pymodpde.DifferentialEquation.symbolic_amp_factor"><code class="name flex">
<span>def <span class="ident">symbolic_amp_factor</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>the</code> <code>symbolic</code> <code>amplification</code> <code>factor</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symbolic_amp_factor(self):
    &#39;&#39;&#39;
    Returns:
         the symbolic amplification factor
    &#39;&#39;&#39;
    if self.__amp_factor == None:
        raise Exception(&#39;the amplification factor is not generated yet. try calling the generate_modified_equation or generate_amp_factor functions first.&#39;)
    else:
        return self.__amp_factor</code></pre>
</details>
</dd>
<dt id="pymodpde.DifferentialEquation.symbolic_modified_equation"><code class="name flex">
<span>def <span class="ident">symbolic_modified_equation</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>the</code> <code>symbolic</code> <code>modified</code> <code>equation</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symbolic_modified_equation(self):
    &#39;&#39;&#39;
    Returns:
         the symbolic modified equation
    &#39;&#39;&#39;
    if self.__ME == None:
        raise Exception(
            &#39;the modified equation is not generated yet. try calling the generate_modified_equation function first.&#39;)
    else:
        return self.__ME</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pymodpde.DifferentialEquation" href="#pymodpde.DifferentialEquation">DifferentialEquation</a></code></h4>
<ul class="">
<li><code><a title="pymodpde.DifferentialEquation.dependent_var_func" href="#pymodpde.DifferentialEquation.dependent_var_func">dependent_var_func</a></code></li>
<li><code><a title="pymodpde.DifferentialEquation.display_amp_factor" href="#pymodpde.DifferentialEquation.display_amp_factor">display_amp_factor</a></code></li>
<li><code><a title="pymodpde.DifferentialEquation.display_modified_equation" href="#pymodpde.DifferentialEquation.display_modified_equation">display_modified_equation</a></code></li>
<li><code><a title="pymodpde.DifferentialEquation.expr" href="#pymodpde.DifferentialEquation.expr">expr</a></code></li>
<li><code><a title="pymodpde.DifferentialEquation.generate_amp_factor" href="#pymodpde.DifferentialEquation.generate_amp_factor">generate_amp_factor</a></code></li>
<li><code><a title="pymodpde.DifferentialEquation.generate_modified_equation" href="#pymodpde.DifferentialEquation.generate_modified_equation">generate_modified_equation</a></code></li>
<li><code><a title="pymodpde.DifferentialEquation.independentVars" href="#pymodpde.DifferentialEquation.independentVars">independentVars</a></code></li>
<li><code><a title="pymodpde.DifferentialEquation.latex_amp_factor" href="#pymodpde.DifferentialEquation.latex_amp_factor">latex_amp_factor</a></code></li>
<li><code><a title="pymodpde.DifferentialEquation.latex_modified_equation" href="#pymodpde.DifferentialEquation.latex_modified_equation">latex_modified_equation</a></code></li>
<li><code><a title="pymodpde.DifferentialEquation.set_rhs" href="#pymodpde.DifferentialEquation.set_rhs">set_rhs</a></code></li>
<li><code><a title="pymodpde.DifferentialEquation.symbolic_amp_factor" href="#pymodpde.DifferentialEquation.symbolic_amp_factor">symbolic_amp_factor</a></code></li>
<li><code><a title="pymodpde.DifferentialEquation.symbolic_modified_equation" href="#pymodpde.DifferentialEquation.symbolic_modified_equation">symbolic_modified_equation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>